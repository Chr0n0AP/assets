## START COPYRIGHT
/* ===================== COPYRIGHT NOTICE =====================
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of REDHAWK.
 *
 * REDHAWK is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * REDHAWK is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 * ============================================================
 */
## END

## START COMMENTS
/** <b>Internal Use Only:</b> Pack/unpack methods used by {@link BasicDataPacket}. <br>
 *  <br>
 *  <h2>Usage Notes</h2>
 *  <ul>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual range limits is
 *        undefined. <i>(For example inserting the value 1024 from an Int32
 *        array into a PayloadFormat of Int8.)</i></li>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual precision limits
 *        will result in a loss of precision. (For example inserting the value
 *        3.14 from an Float32 array into a PayloadFormat of Int8 will result in
 *        the value 3 being set.)</li>
 *    <li>The handling of NaN, +Inf, and -Inf when converting from a floating-point
 *        type to an integer type is undefined.</li>
 *    <li>All floating-point NaN values are considered equal any NaN may be
 *        converted to any other NaN (i.e. "signaling NaN values" are not
 *        preserved).</li>
 *    <li>All floating-point 0.0 values (i.e. -0.0 and +0.0) are considered equal
 *        and any 0.0 may be converted to any other 0.0 (i.e. the sign bit on
 *        a 0.0 is not preserved).</li>
 *  </ul>
 *  <h2>Performance Characteristics</h2>
 *  Great effort has been made to optimize the most commonly used pack/unpack
 *  conversions. The table below shows the relative speed at which a given
 *  PayloadFormat can be packed/unpacked from a buffer.
 *  <pre>
 *       Speed   | Item Packing | Data Item |  Event   | Channel  | Efficient | Notes |
 *        [0]    |  Field Size  | Size [1]  | Tag Size | Tag Size |   Mode    |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A+    |       8      |     8     |    0     |     0    | Link/Proc |       |
 *     (Fastest) |              |           |          |          |           |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A     |       1      |     1     |    0     |     0    | Link/Proc |  [2]  |
 *               |       4      |     4     |    0     |     0    | Link/Proc |  [2]  |
 *               |      12      |    12     |    0     |     0    | Link/Proc |  [2]  |
 *               |      16      |    16     |    0     |     0    | Link/Proc |       |
 *               |      24      |    24     |    0     |     0    | Link/Proc |       |
 *               |      32      |    32     |    0     |     0    | Link/Proc |       |
 *               |      64      |    64     |    0     |     0    | Link/Proc |       |
 *               |      32      |   float   |    0     |     0    | Link/Proc |       |
 *               |      64      |   double  |    0     |     0    | Link/Proc |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A-    |       8      |  1 to  7  |    -     |     -    | Link/Proc |  [3]  |
 *               |      16      |  1 to 15  |    -     |     -    | Link/Proc |  [3]  |
 *               |      24      |  1 to 23  |    -     |     -    | Link/Proc |  [3]  |
 *               |      32      |  1 to 31  |    -     |     -    | Link/Proc |  [3]  |
 *               |      64      |  1 to 63  |    -     |     -    | Link/Proc |  [3]  |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         B     |      32      |  1 to 31  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |  1 to 63  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |   float   |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Proc   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D+    |    1 to 15   |  1 to 15  |    -     |     -    | Link/Proc | [3,4] |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Link   |  [3]  |
 *               |   33 to 63   |   float   |    -     |     -    |    Link   |  [3]  |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D     |    1 to 15   |  1 to 15  |  0 to 7  |  0 to 15 | Link/Proc |  [4]  |
 *     (Slowest) |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Link   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Link   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *
 *    Notes:
 *      [0] The "speed" rating is an arbitrary "grade" indicating how fast the accessing
 *          of a given Payload Format is relative to other Payload Formats, where an
 *          "A+" equates to a simple memcpy in C++ and a "D" equates to a complex
 *          processing algorithm with nested loops and heavy use of bit manipulation.
 *          In practice the speed difference in speed between a "B" and an "A" is
 *          small whereas the difference between a "B" and a "D" is many orders of
 *          magnitude slower. <i>(For example, on one test of ~2 million iterations using
 *          both link efficient ("D") and processing efficient ("B") and with Packing
 *          Field Sizes between 33 and 63 bits it took 38.2 sec for link efficient vs
 *          &lt;0.1 sec for processing efficient.)</i>
 *      [1] All Data items are signed/unsigned integers with the bit count as shown,
 *          except for "float" and "double" which represent IEEE-754 floating-point
 *          values.
 *      [2] Fast handling of Int1 and Int4/Int12 data by unpacking eight/two elements
 *          at a time. Total length must be a multiple of 8/2 to use this mode.
 *      [3] Event/Channel tags (if present) are not read and set to zero on write.
 *      [4] Future versions may provide a faster implementation for 1 to 15 bit
 *          field sizes when in Processing Efficient mode.
 *  </pre>
 *  Currently all of the VRT floating-point formats are using algorithms that
 *  are similar to the "D+" and "D" ones used for IEEE-754 float data. Future
 *  versions may provide a faster implementation for situations where the data
 *  item size is 8/16/32/64 bits and/or processing-efficient mode is used. <br>
 *  <br>
 *  Regardless of the algorithm used herein, the accessing of IEEE-754
 *  floating-point values will always be faster than the accessing of VRT
 *  floating-point values since the former benefit from hardware acceleration.
 */
## END

## START BITS
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
 *  1 bit will correspond to the value 1.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackBits (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  if (sign) {
    // This uses sign-extending principles to get each bit as 0 or -1 which reflects
    // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
    // twos-complement.
    #parallel#
    for (int i = 0; i < length; i+=8) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b << 24) >> 31);
      array[offset++] = (#type#)((b << 25) >> 31);
      array[offset++] = (#type#)((b << 26) >> 31);
      array[offset++] = (#type#)((b << 27) >> 31);
      array[offset++] = (#type#)((b << 28) >> 31);
      array[offset++] = (#type#)((b << 29) >> 31);
      array[offset++] = (#type#)((b << 30) >> 31);
      array[offset++] = (#type#)((b << 31) >> 31);
    }
  }
  else {
    #parallel#
    for (int i = 0; i < length; i+=8) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b >> 7) & 0x1);
      array[offset++] = (#type#)((b >> 6) & 0x1);
      array[offset++] = (#type#)((b >> 5) & 0x1);
      array[offset++] = (#type#)((b >> 4) & 0x1);
      array[offset++] = (#type#)((b >> 3) & 0x1);
      array[offset++] = (#type#)((b >> 2) & 0x1);
      array[offset++] = (#type#)((b >> 1) & 0x1);
      array[offset++] = (#type#)((b     ) & 0x1);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a zero value will correspond to the bit 0 and
 *  any non-zero value will correspond to the bit 1.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packBits (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  #parallel#
  for (int i = 0; i < length; i+=8) {
    int b = 0;
    b |= (((#container#)array[offset++]) << 7) & 0x80;
    b |= (((#container#)array[offset++]) << 6) & 0x40;
    b |= (((#container#)array[offset++]) << 5) & 0x20;
    b |= (((#container#)array[offset++]) << 4) & 0x10;
    b |= (((#container#)array[offset++]) << 3) & 0x08;
    b |= (((#container#)array[offset++]) << 2) & 0x04;
    b |= (((#container#)array[offset++]) << 1) & 0x02;
    b |= (((#container#)array[offset++])     ) & 0x01;
    buf[off++] = (byte)b;
  }
}
## END

## START BOOLEAN_BITS
/** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
 *  input buffer will be checked, a 0 bit will correspond to the value false and
 *  a 1 bit will correspond to the value true.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
private static void #namespace#unpackBits (const byte[] buf, int off, boolean[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // Unpack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  #parallel#
  for (int i = 0; i < length; i+=8) {
    byte b = buf[off++];
    array[offset++] = ((b & 0x80) != 0);
    array[offset++] = ((b & 0x40) != 0);
    array[offset++] = ((b & 0x20) != 0);
    array[offset++] = ((b & 0x10) != 0);
    array[offset++] = ((b & 0x08) != 0);
    array[offset++] = ((b & 0x04) != 0);
    array[offset++] = ((b & 0x02) != 0);
    array[offset++] = ((b & 0x01) != 0);
  }
}
/** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
 *  input array will be checked, a false value will correspond to the bit 0 and
 *  a true value will correspond to the bit 1.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
 *  @param fSize  (IN)  Item packing field size in bits (must be 1)
 *  @param dSize  (IN)  Data item size in bits (must be 1)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
private static void #namespace#packBits (byte[] buf, int off, const boolean[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // Pack function for signed and unsigned are identical for bit data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  #parallel#
  for (int i = 0; i < length; i+=8) {
    int b = 0;
    b |= (array[offset++])? 0x80 : 0x00;
    b |= (array[offset++])? 0x40 : 0x00;
    b |= (array[offset++])? 0x20 : 0x00;
    b |= (array[offset++])? 0x10 : 0x00;
    b |= (array[offset++])? 0x08 : 0x00;
    b |= (array[offset++])? 0x04 : 0x00;
    b |= (array[offset++])? 0x02 : 0x00;
    b |= (array[offset++])? 0x01 : 0x00;
    buf[off++] = (byte)b;
  }
}
## END

## START NIBBLES
/** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackNibbles (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  if (sign) {
    #parallel#
    for (int i = 0; i < length; i+=2) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b << 24) >> 28); // shift & sign extend
      array[offset++] = (#type#)((b << 28) >> 28); // shift & sign extend
    }
  }
  else {
    #parallel#
    for (int i = 0; i < length; i+=2) {
      int b = (int)buf[off++];
      array[offset++] = (#type#)((b >> 4) & 0xF);
      array[offset++] = (#type#)((b     ) & 0xF);
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 4)
 *  @param dSize  (IN)  Data item size in bits (must be 4)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packNibbles (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // Pack function for signed and unsigned are identical for nibble data, hence
  // 'sign' is unused here, but included in function definition for consistency.
  #parallel#
  for (int i = 0; i < length; i+=2) {
    int first  = (int)(#ct#)array[offset++];
    int second = (int)(#ct#)array[offset++];
    buf[off++] = (byte)((first << 4) | (second & 0xF));
  }
}
## END

## START INT12S
/** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#unpackInt12s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  int skip = (align)? 1 : 0;
  if (sign) {
    #parallel#
    for (int i = 0; i < length; i+=2) {
      int a = (int)buf[off++];
      int b = (int)buf[off++];
      int c = (int)buf[off++];

      int x = (a << 4) | ((b >> 4) & 0x000F);
      int y = (b << 8) | ((c     ) & 0x00FF);

      array[offset++] = (#type#)((x << 20) >> 20); // sign extend
      array[offset++] = (#type#)((y << 20) >> 20); // sign extend
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  else {
    #parallel#
    for (int i = 0; i < length; i+=2) {
      int a = (int)buf[off++];
      int b = (int)buf[off++];
      int c = (int)buf[off++];

      int x = (a << 4) | ((b >> 4) & 0x000F);
      int y = (b << 8) | ((c     ) & 0x00FF);

      array[offset++] = (#type#)(x & 0x0FFF); // clear high-order bits
      array[offset++] = (#type#)(y & 0x0FFF); // clear high-order bits
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
 *  @param fSize  (IN)  Item packing field size in bits (must be 12)
 *  @param dSize  (IN)  Data item size in bits (must be 12)
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static void #namespace#packInt12s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  int skip = (align)?  1 : 0;
  int mask = (sign )? -1 : ((int)#typemask#);
  #parallel#
  for (int i = 0; i < length; i+=2) {
    int first  = ((int)(#ct#)array[offset++]) & mask;
    int second = ((int)(#ct#)array[offset++]) & mask;
    buf[off++] = (byte)(first >> 4);
    buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
    buf[off++] = (byte)(second);
    off += skip; // skip extra byte in processing-efficient mode
  }
}
## END

## START INTEGER
/** <b>Internal Use Only:</b> Fast unpack method for signed #form# data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#unpack#Form#s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
#IF (#typecheck# == #formbytes#) && (#typecheck# == 1) && #JAVA#
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    System.arraycopy(buf, off, array, offset, length);
    return;
  }
#ELSEIF (#typecheck# == #formbytes#) && #JAVA# && #UNSAFE#
  if ((fSize == #formbits#) && (dSize == #formbits#) && (unsafe != null)) {
    // Fast array copy
    unsafe.copyMemory(buf, byteArrayOffset + off, array, #type#ArrayOffset + (offset * #typebytes#), length*#typebytes#);
    // Fast byte swap
    int end = offset + length;
    for (int i = offset; i < end; i++) {
      array[i] = #TypeClass#.reverseBytes(array[i]);
    }
//    long pos = byteArrayOffset + off;
//    for (int i=0,j=offset; i < length; i++,j++,pos+=#typebytes#) {
//      array[j] = #TypeClass#.reverseBytes(unsafe.get#Type#(buf, pos));
//    }
//    return;
  }
#ELSEIF (#typecheck# == #formbytes#) && #CPP#
#if (#typebytes# == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    memcpy(&array[offset], &buf[off], length*#typebytes#);
    return;
  }
#endif
#ENDIF

#IF (#formbytes# < 3)
  UNUSED_VARIABLE(align);
  int delta = fSize / 8; // byte offset delta
#ELSE
  int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
#ENDIF

  if (sign) {
    if (dSize == #formbits#) {
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)unpack#Form#(buf, off);
      }
    }
    else {
      int shift  = #formbits# - dSize;
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)(unpack#Form#(buf, off) >> shift);
      }
    }
  }
  else {
    if (dSize == #formbits#) {
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=delta) {
#IF (#JAVA# && (#formbits# == 64) && (#typecheck# <= -4))
        // Special handling for UInt64->Float and UInt64->Double required since
        // Java only has signed values.
        #form# bits = unpack#Form#(buf, off);
        array[offset++] = (bits >= 0)? (#type#)bits
                                     : (#type#)((bits & 0x7FFFFFFFFFFFFFFFL) + 9223372036854775808.0);
#ELSE
        array[offset++] = (#type#)(unpack#Form#(buf, off) & #mask#);
#ENDIF
      }
    }
    else {
      int shift  = #formbits# - dSize;
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=delta) {
        array[offset++] = (#type#)((unpack#Form#(buf, off) & #mask#) >>> shift);
      }
    }
  }
}
/** <b>Internal Use Only:</b> Fast pack method for unsigned #form# data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#pack#Form#s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
#IF (#typecheck# == #formcheck#) && (#typecheck# == 1) && #JAVA#
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    System.arraycopy(array, offset, buf, off, length);
    return;
  }
#ELSEIF (#typecheck# == #formcheck#) && ((#typecheck# == 1) || (#typecheck# == 2) || (#typecheck# == 4) || (#typecheck# == 8)) && #CPP#
#if (#typebytes# == 1) || (BYTE_ORDER == BIG_ENDIAN)
  if ((fSize == #formbits#) && (dSize == #formbits#)) {
    // Fast array copy
    memcpy(&buf[off], &array[offset], length*#typebytes#);
    return;
  }
#endif
#ENDIF

#IF (#formbytes# < 3)
  UNUSED_VARIABLE(align);
  int delta = fSize / 8; // byte offset delta
#ELSE
  int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
#ENDIF
  #form# valMask = (sign)? ((#form#)-1) : ((#form#)#typemask#); // Bit mask for input value (controls sign-extend)

  if (dSize == #formbits#) {
    if (delta == #formbytes#) {
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=#formbytes#) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, val);
      }
    }
    else {
      #parallel#
      for (int i = 0; i < length; i++) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, val);
        off += #formbytes#;
        #loop1N#
        for (int j = #formbytes#; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  else {
    int shift = #formbits# - dSize;
    if (delta == #formbytes#) {
      #inline_recursive#
      #parallel#
      for (int i = 0; i < length; i++,off+=#formbytes#) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, (#form#)(val << shift));
      }
    }
    else {
      #parallel#
      for (int i = 0; i < length; i++) {
        #form# val = (#form#)(((#form#)(#ct#)array[offset++]) & valMask);
        pack#Form#(buf, off, (#form#)(val << shift));
        off += #formbytes#;
        #loop1N#
        for (int j = #formbytes#; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
}
## END


## START FPOINT
/** <b>Internal Use Only:</b> Fast unpack method for #form# data.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (OUT) Output array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be #formbits#)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#unpack#Form#s (const byte[] buf, int off, #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
#IF (#formbits# == 64)
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // When using #Form# data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#formbytes#) {
    array[offset++] = (#type#)unpack#Form#(buf, off);
  }
#ELSE
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(dSize);
  int delta; // byte offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;

  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=delta) {
    array[offset++] = (#type#)unpack#Form#(buf, off);
  }
#ENDIF
}
/** <b>Internal Use Only:</b>
 *  Fast pack method for #form# data.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input array
 *  @param offset (IN)  Offset into array
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
 *  @param dSize  (IN)  Data item size in bits (must be #formbits#)
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed? (must be true)
 */
@SuppressWarnings("cast")
private static #flatten# void #namespace#pack#Form#s (byte[] buf, int off, const #type#[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
  // All floating-point values are signed, so 'sign' is unused, but is included
  // in function definition for consistency.
#IF (#formbits# == 64)
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(align);
  UNUSED_VARIABLE(dSize);
  UNUSED_VARIABLE(fSize);
  // When using #Form# data, it is required that dSize=64 and fSize=64 so we can
  // skip some of the normal checks we would otherwise do here.
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#formbytes#) {
    pack#Form#(buf, off, (#form#)array[offset++]);
  }
#ELSE
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(dSize);
  int delta; // byte offset delta
  if (align) delta = (fSize <= 32)? 4 : 8;
  else       delta = fSize / 8;

  if (delta == #formbytes#) {
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++,off+=#formbytes#) {
      pack#Form#(buf, off, (#form#)array[offset++]);
    }
  }
  else {
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++) {
      pack#Form#(buf, off, (#form#)array[offset++]);
      off += #formbytes#;
      #loop1N#
      for (int j = #formbytes#; j < delta; j++) {
        buf[off++] = 0; // set unused bits to zero
      }
    }
  }
#ENDIF
}
## END

## START BUFFER
/** <b>Internal Use Only:</b> Gets the data into an array.
 *  @param buf       (IN)  Packet payload buffer
 *  @param bitOffset (IN)  Bit offset into buf (must be multiple of #wordbits# bits)
 *  @param array     (OUT) Output value array (not null)
 *  @param chan      (OUT) Output channel tag array (null if n/a)
 *  @param evt       (OUT) Output event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
#IF (#formcheck# == -100)
private static void #namespace#unpackVRTFloatBuffer#wordbits# (const byte[] buf, int bitOffset, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign, int expBits) {
#ELSE
private static void #namespace#unpack#Form#Buffer#wordbits# (const byte[] buf, int bitOffset, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
#ENDIF
  final int bitmask      = #wordbits# - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  final int bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
#IF ((#formcheck# != -4) && (#formcheck# != -100))
  int _bits_dSize  = #wordbits# - dSize;    // pre-compute "#wordbits# - dSize" for efficiency
#ENDIF
  int _bits_fSize  = #wordbits# - fSize;    // pre-compute "#wordbits# - fSize" for efficiency
  int _fSize_dSize = fSize - dSize;         // pre-compute "fSize - dSize" for efficiency

  int eMask = (0x1 << eSize) - 1;
  int cMask = (0x1 << cSize) - 1;

  for (int i = 0; i < length; i++) {
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      // Not enough bits remaining in this word, move to next word (skipping pad bits)
      bitOffset = (bitOffset + 32) & bitmaskInv;
    }

    #word# bits  = unpackBits#wordbits#(buf, bitOffset, fSize);
    #word# value = bits >> _fSize_dSize;

#IF (#formcheck# == -4)
    UNUSED_VARIABLE(sign);
    array[i] = (#type#)intBitsToFloat((int)value);
#ELSEIF (#formcheck# == -100)
    array[i] = (#type#)fromVRTFloat#wordbits#(sign, expBits, dSize, value);
#ELSE
    // sign extend as needed (otherwise leave top bits 0)
    array[i] = (sign)? (#type#)((value << _bits_dSize) >>  _bits_dSize)
                     : (#type#)value;
#ENDIF

    if (evt  != null) evt[i]  = ((int)(bits >> cSize)) & eMask;
    if (chan != null) chan[i] = ((int)(bits         )) & cMask;

    bitOffset += fSize;
  }
}
/** <b>Internal Use Only:</b> Sets the data from an array.
 *  @param buf       (I/O) Packet payload buffer
 *  @param bitOffset (IN)  Bit offset into buf
 *  @param array     (IN)  Input value array
 *  @param chan      (IN)  Input channel tag array (null if n/a)
 *  @param evt       (IN)  Input event tag array (null if n/a)
 *  @param length    (IN)  Number of elements to convert
 *  @param fSize     (IN)  Item packing field size in bits
 *  @param dSize     (IN)  Data item size in bits
 *  @param eSize     (IN)  Event tag size in bits
 *  @param cSize     (IN)  Channel tag size in bits
 *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
#IF (#formcheck# == -100)
private static void #namespace#packVRTFloatBuffer#wordbits# (byte[] buf, int bitOffset, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign, int expBits) {
#ELSE
private static void #namespace#pack#Form#Buffer#wordbits# (byte[] buf, int bitOffset, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
#ENDIF
  final int bitmask      = #wordbits# - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
  final int bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+
  //   | Data Item | Unused | Event Tag | Channel Tag |
  //   +-----------+--------+-----------+-------------+
  //       dSize      uSize     eSize       cSize
  //   |------------------ fSize ---------------------|
  int uSize        = fSize - dSize - eSize - cSize;
  int _bits_fSize  = #wordbits# - fSize;    // pre-compute "#wordbits# - fSize" for efficiency
#IF ((#formcheck# != -4) && (#formcheck# != -100))
  #word# valMask      = (sign)? ((#word#)-1) : ((#word#)#typemask#); // Bit mask for input value (controls sign-extend)
#ELSE
  UNUSED_VARIABLE(sign); // don't need to worry about sign-extend
#ENDIF

  if ((evt == null) || (eSize == 0)) {
    // Treat event tag as unused since we have nothing to insert there (this
    // will be slightly faster in the loop below).
    uSize = uSize + eSize;
    eSize = 0;
    evt   = null;

    if (chan == null) {
      // Treat channel tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + cSize;
      cSize = 0;
      chan  = null;
    }
  }
  int eMask = (0x1 << eSize) - 1;
  int cMask = (0x1 << cSize) - 1;
  int _uSize_eSize = uSize + eSize;         // pre-compute "uSize + eSize" for efficiency

  for (int i = 0; i < length; i++) {
    if (align && ((bitOffset & bitmask) > _bits_fSize)) {
      if (true) { //TODO: make this optional
        // Not enough bits remaining in this word, move to next word (clearing pad bits)
        int zSize = #wordbits# - (bitOffset & bitmask); // bits remaining to set
        packBits#wordbits#(buf, bitOffset, zSize, 0);
        bitOffset += zSize;
      }
      else {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
    }

#IF (#formcheck# == -4)
    #word# value = (#word#)floatToRawIntBits((float)array[i]);
#ELSEIF (#formcheck# == -100)
    #word# value = toVRTFloat#wordbits#(sign, expBits, dSize, (double)array[i]);
#ELSE
    #word# value = (#word#)(((#word#)(#ct#)array[i]) & valMask);
#ENDIF

    value = value << _uSize_eSize;
    if (evt != null) value = value | (evt[i] & eMask);
    value = value << cSize;
    if (chan != null) value = value | (chan[i] & cMask);
    packBits#wordbits#(buf, bitOffset, fSize, value);
    bitOffset += fSize;
  }

  // ==== End of Packet Pad Bits ===============================================
  // Clear out any bits remaining in the current word that would be at the end
  // of the packet, this applies to both link and processing efficient.
  if (true) { //TODO: make this optional
    int xSize = #wordbits# - (bitOffset & bitmask); // bits remaining to set
    if (xSize > 0) {
      packBits#wordbits#(buf, bitOffset, xSize, 0);
      bitOffset += xSize;
    }
  }
}
## END

## START WORD
/** <b>Internal Use Only:</b> Gets the data into an array, where the data is
 *  aligned to #wordbits#-bit word boundaries.
 *  @param buf    (IN)  Packet payload buffer
 *  @param off    (IN)  Bit offset into buf (must be multiple of #wordbits# bits)
 *  @param array  (OUT) Output value array (not null)
 *  @param chan   (OUT) Output channel tag array (null if n/a)
 *  @param evt    (OUT) Output event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
#IF (#formcheck# == -100)
private static void #namespace#unpackVRTFloatWord#wordbits# (const byte[] buf, int off, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign, int expBits) {
#ELSE
private static void #namespace#unpack#Form#Word#wordbits# (const byte[] buf, int off, #type#[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
#ENDIF
  UNUSED_VARIABLE(align);
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int pSize    = #wordbits# - fSize;
  int evtMask  = ~(((int)-1) << eSize);
  int chanMask = ~(((int)-1) << cSize);

#IF (#formcheck# == -4)
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(dSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    array[i] = (#type#)unpackFloat(buf, off);
    int value = unpackInt(buf, off+4);
    if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
#ELSEIF (#wordbits# == 64)
# IF (#formcheck# != -100)
  #word# valMask  = (sign)? ((#word#)-1) : (~(((#word#)-1) << dSize));
# ELSE
  UNUSED_VARIABLE(sign); // don't need to worry about sign-extend
# ENDIF
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      int val   = unpackInt(buf, off);
      int value = unpackInt(buf, off+4);
# IF (#formcheck# == -100)
      array[i] = (#type#)fromVRTFloat32(sign, expBits, dSize, val);
# ELSE
      array[i] = (#type#)(val & valMask);
# ENDIF
      if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
      if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
    }
  }
  else {
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
      long value = unpackLong(buf, off);
# IF (#formcheck# == -100)
      long bits  = (value >> (64-dSize)); // fromVRTFloat64(..) will mask off any extra bits
      array[i] = (#type#)fromVRTFloat64(sign, expBits, dSize, bits);
# ELSE
      array[i] = (#type#)((value >> (64-dSize)) & valMask);
# ENDIF
      if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
      if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
    }
  }
#ELSE
# IF (#formcheck# != -100)
  #word# valMask  = (sign)? ((#word#)-1) : (~(((#word#)-1) << dSize));
# ELSE
  UNUSED_VARIABLE(sign); // don't need to worry about sign-extend
# ENDIF
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    int value = unpackInt(buf, off);
# IF (#formcheck# == -100)
    int bits  = (value >> (32-dSize)); // fromVRTFloat32(..) will mask off any extra bits
    array[i] = (#type#)fromVRTFloat32(sign, expBits, dSize, bits);
# ELSE
    array[i] = (#type#)((value >> (32-dSize)) & valMask);
# ENDIF
    if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
    if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
  }
#ENDIF
}
/** <b>Internal Use Only:</b> Sets the data from an array, where the data is
 *  aligned to #wordbits#-bit word boundaries.
 *  @param buf    (I/O) Packet payload buffer
 *  @param off    (IN)  Offset into buf
 *  @param array  (IN)  Input value array
 *  @param chan   (IN)  Input channel tag array (null if n/a)
 *  @param evt    (IN)  Input event tag array (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @param fSize  (IN)  Item packing field size in bits
 *  @param dSize  (IN)  Data item size in bits
 *  @param eSize  (IN)  Event tag size in bits
 *  @param cSize  (IN)  Channel tag size in bits
 *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
 *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
 */
@SuppressWarnings("cast")
#IF (#formcheck# == -100)
private static void #namespace#packVRTFloatWord#wordbits# (byte[] buf, int off, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign, int expBits) {
#ELSE
private static void #namespace#pack#Form#Word#wordbits# (byte[] buf, int off, const #type#[] array, const int[] chan, const int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
#ENDIF
  UNUSED_VARIABLE(align);
  // Item Packing Field
  //   +-----------+--------+-----------+-------------+- - - - - +
  //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
  //   +-----------+--------+-----------+-------------+- - - - - +
  //       dSize      uSize     eSize       cSize        pSize
  //   |------------------ fSize ---------------------|
  //   |---------------------- Word Size ------------------------|
  int pSize    = #wordbits# - fSize;
  int evtMask  = ~(((int)-1) << eSize);
  int chanMask = ~(((int)-1) << cSize);

#IF (#formcheck# == -4)
  UNUSED_VARIABLE(sign);
  UNUSED_VARIABLE(dSize);
  // When using Float32 the first 32-bits will always the the Float32 value, so
  // use 32-bit operations to improve performance
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
    float val   = (float)array[i];
    int   value = 0;
    if (chan != null) value  = (chan[i] & chanMask) << (pSize);
    if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packFloat(buf, off,   val);
    packInt(  buf, off+4, value);
  }
#ELSEIF (#wordbits# == 64)
# IF (#formcheck# != -100)
  #word# valMask  = (sign)? ((#word#)-1) : ((#word#)#typemask#);
# ELSE
  UNUSED_VARIABLE(sign); // don't need to worry about sign-extend
# ENDIF
  if (dSize == 32) {
    // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
    // value, so use 32-bit operations to improve performance
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
# IF (#formcheck# == -100)
      int val   = toVRTFloat32(sign, expBits, dSize, (double)array[i]);
# ELSE
      int val   = (int)(((#word#)(#ct#)array[i]) & valMask);
# ENDIF
      int value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off,   val);
      packInt(buf, off+4, value);
    }
  }
  else {
    #inline_recursive#
    #parallel#
    for (int i = 0; i < length; i++,off+=#wordbytes#) {
# IF (#formcheck# == -100)
      long val   = toVRTFloat64(sign, expBits, dSize, (double)array[i]);
# ELSE
      long val   = (long)(((#word#)(#ct#)array[i]) & valMask);
# ENDIF
      long value = val << (64-dSize);
      if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
      if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
      packLong(buf, off, value);
    }
  }
#ELSE
# IF (#formcheck# != -100)
  #word# valMask  = (sign)? ((#word#)-1) : ((#word#)#typemask#);
# ELSE
  UNUSED_VARIABLE(sign); // don't need to worry about sign-extend
# ENDIF
  #inline_recursive#
  #parallel#
  for (int i = 0; i < length; i++,off+=#wordbytes#) {
# IF (#formcheck# == -100)
    int val   = toVRTFloat32(sign, expBits, dSize, (double)array[i]);
# ELSE
    int val   = (int)(((#word#)(#ct#)array[i]) & valMask);
# ENDIF
    int value = val << (32-dSize);
    if (chan != null) value |= (chan[i] & chanMask) << (pSize);
    if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
    packInt(buf, off, value);
  }
#ENDIF
}
## END

## START GENERIC
/** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
 *  an array of <tt>#type#</tt>. <br>
 *  <br>
 *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
 *  arrays to null will cause any channel or event tags present to be ignored.
 *  In most cases this results in a performance improvement. <br>
 *  <br>
 *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
 *  are non-null when there are no channel or event tags present, the values in
 *  the arrays will not be modified.
 *  @param pf     (IN)  The data format
 *  @param buf    (IN)  The buffer
 *  @param off    (IN)  The buffer offset
 *  @param array  (OUT) The output array for the values
 *  @param chan   (OUT) The output array for the channel tags (null if n/a)
 *  @param evt    (OUT) The output array for the event tags (null if n/a)
 *  @param length (IN)  Number of elements to convert
 *  @return The output array (same as <tt>array</tt>).
 */
@SuppressWarnings("fallthrough")
public static #type#[] #namespace##pureJava#unpackAs#Type# (PayloadFormat pf, const byte[] buf, int off, #type#[] array, int[] chan, int[] evt, int length) {
#IF #NATIVE#
  if (noJNI) {
    return pureJava_unpackAs#Type#(pf, buf, off, array, chan, evt, length);
  }
#ENDIF
  if (!pf.isValid()) {
    throw IllegalArgumentError(pf.getValid());
  }
  int            fSize  = pf.getItemPackingFieldSize();
  int            dSize  = pf.getDataItemSize();
  int            eSize  = pf.getEventTagSize();
  int            cSize  = pf.getChannelTagSize();
  int            xSize  = fSize; // effective fSize
  boolean        proc   = pf.isProcessingEfficient();
  boolean        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  boolean        noTags;

  if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
  if (cSize == 0) chan = null; // no channel tags, ignore any array passed in

  noTags = ((chan == null) && (evt == null)) || (fSize == dSize);

  if (proc) {
         if (fSize >= 33) xSize = 64;
    else if (fSize >= 17) xSize = 32;

    if (noTags) fSize = xSize; // Use faster field size if ignoring Event & Channel Tags
  }

  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: #native#unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 16: #native#unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 24: #native#unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 32: #native#unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          case 64: #native#unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { #native#unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case  4: if ((length % 2) == 0) { #native#unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          case 12: if ((length % 2) == 0) { #native#unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
        }
      }
      if (xSize == 32) {
        #native#unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      if (xSize == 64) {
        #native#unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        #native#unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      else {
        #native#unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        #native#unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      }
      if (xSize == 64) {
        #native#unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      #native#unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      #native#unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
    default: // VRTFloat Types
      // ---- Try fast methods -------------------------------------------------
      if (xSize == 32) {
        #native#unpackVRTFloatWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return array;
      }
      if (xSize == 64) {
        #native#unpackVRTFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return array;
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        #native#unpackVRTFloatBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return array;
      }
      else {
        #native#unpackVRTFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return array;
      }
  }
}
/** <b>Internal Use Only:</b> Packs values with the given format specifier from
 *  an array of #type#. <br>
 *  <br>
 *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
 *  arrays to null will cause any channel or event tags present to be set to
 *  zero. In most cases this results in a performance improvement over passing
 *  in an array of zeros. <br>
 *  <br>
 *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
 *  are non-null when there are no channel or event tags present, the values in
 *  the arrays will be ignored.
 *  @param pf     (IN)  The data format
 *  @param buf    (I/O) The buffer
 *  @param off    (IN)  The buffer offset
 *  @param array  (IN)  The values to pack
 *  @param chan   (OUT) The output array for the channel tags (null if n/a)
 *  @param evt    (OUT) The output array for the event tags (null if n/a)
 *  @param length (IN)  Number of elements to convert
 */
@SuppressWarnings("fallthrough")
public static void #namespace##pureJava#packAs#Type# (PayloadFormat pf, byte[] buf, int off, const #type#[] array, const int[] chan, const int[] evt, int length) {
#IF #NATIVE#
  if (noJNI) {
    pureJava_packAs#Type#(pf, buf, off, array, chan, evt, length);
    return;
  }
#ENDIF
  if (!pf.isValid()) {
    throw IllegalArgumentError(pf.getValid());
  }
  int            fSize  = pf.getItemPackingFieldSize();
  int            dSize  = pf.getDataItemSize();
  int            eSize  = pf.getEventTagSize();
  int            cSize  = pf.getChannelTagSize();
  int            xSize  = fSize; // effective fSize
  boolean        proc   = pf.isProcessingEfficient();
  boolean        sign   = pf.isSigned();
  DataItemFormat format = pf.getDataItemFormat();
  boolean        noTags;

  if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
  if (cSize == 0) chan = null; // no channel tags, ignore any array passed in

  noTags = ((chan == null) && (evt == null)) || (fSize == dSize);

  if (proc) {
         if (fSize >= 33) xSize = 64;
    else if (fSize >= 17) xSize = 32;

    if (noTags) fSize = xSize; // Use faster field size if ignoring Event & Channel Tags
  }

  switch (format) {
    case DataItemFormat_SignedInt:   // FALLTHROUGH
    case DataItemFormat_UnsignedInt:
      // ---- Try fast methods -------------------------------------------------
      if (noTags) {
        switch (fSize) {
          case  8: #native#packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 16: #native#packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 24: #native#packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 32: #native#packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          case 64: #native#packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
      }
      if (fSize == dSize) { // implicit noTags=true in this case
        switch (fSize) {
          case  1: if ((length % 8) == 0) { #native#packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case  4: if ((length % 2) == 0) { #native#packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          case 12: if ((length % 2) == 0) { #native#packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
        }
      }
      if (xSize == 32) {
        #native#packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      if (xSize == 64) {
        #native#packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        #native#packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      else {
        #native#packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
    case DataItemFormat_Float:
      // ---- Try fast methods -------------------------------------------------
      if (fSize == dSize) { // implicit noTags=true in this case
        #native#packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      }
      if (xSize == 64) {
        #native#packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      #native#packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
    case DataItemFormat_Double:
      // ---- Only fast method for double (yea!) -------------------------------
      #native#packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
    default: // VRTFloat Types
      // ---- Try fast methods -------------------------------------------------
      if (xSize == 32) {
        #native#packVRTFloatWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return;
      }
      if (xSize == 64) {
        #native#packVRTFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return;
      }
      // ---- Fall back to slow method -----------------------------------------
      if (fSize <= 32) {
        #native#packVRTFloatBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return;
      }
      else {
        #native#packVRTFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign, getExponentBits(format)); return;
      }
  }
}
## END
